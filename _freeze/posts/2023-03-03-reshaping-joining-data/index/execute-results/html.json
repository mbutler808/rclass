{
  "hash": "89855af98a0ad1dc89ce66537c6c740b",
  "result": {
    "markdown": "---\ntitle: \"Reshaping and joining data with dplyr\"\nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"Add\"\ndate: 2023-02-28\ncategories: [module 3, week 7, tidyr, tidyverse, dplyr, tibble, pipe]\n---\n\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://r4ds.had.co.nz/tidy-data>\n2.  [tidyr cheat sheet from RStudio](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)\n3.  <https://r4ds.had.co.nz/relational-data>\n4.  <https://rafalab.github.io/dsbook/joining-tables>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://www.stephaniehicks.com/jhustatcomputing2022/posts/2022-09-08-tidy-data-and-the-tidyverse/>\n-   <https://www.stephaniehicks.com/jhustatcomputing2022/posts/2022-09-08-joining-data-in-r/>\n-   <https://rdpeng.github.io/Biostat776/lecture-joining-data-in-r-basics>\n-   <https://r4ds.had.co.nz/relational-data>\n-   <https://rafalab.github.io/dsbook/joining-tables>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Be able to transform wide data into long data\n-   Be able to separate character columns into multiple columns\n-   Be able to unite/separate multiple character columns into one column\n-   Be able to define relational data and keys\n-   Be able to define the three types of join functions for relational data\n-   Be able to implement mutational join functions\n:::\n\n# Overview\n\nLast time we talked about tidy data. One common issue is that people sometimes use column names to store data. For example take a look at this built-in dataset that comes with `tidyr` on **religion and income survey data** with the number of respondents with income range in column name.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\nrelig_income\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 18 × 11\n   religion      `<$10k` $10-2…¹ $20-3…² $30-4…³ $40-5…⁴ $50-7…⁵ $75-1…⁶ $100-…⁷\n   <chr>           <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 Agnostic           27      34      60      81      76     137     122     109\n 2 Atheist            12      27      37      52      35      70      73      59\n 3 Buddhist           27      21      30      34      33      58      62      39\n 4 Catholic          418     617     732     670     638    1116     949     792\n 5 Don’t know/r…      15      14      15      11      10      35      21      17\n 6 Evangelical …     575     869    1064     982     881    1486     949     723\n 7 Hindu               1       9       7       9      11      34      47      48\n 8 Historically…     228     244     236     238     197     223     131      81\n 9 Jehovah's Wi…      20      27      24      24      21      30      15      11\n10 Jewish             19      19      25      25      30      95      69      87\n11 Mainline Prot     289     495     619     655     651    1107     939     753\n12 Mormon             29      40      48      51      56     112      85      49\n13 Muslim              6       7       9      10       9      23      16       8\n14 Orthodox           13      17      23      32      32      47      38      42\n15 Other Christ…       9       7      11      13      13      14      18      14\n16 Other Faiths       20      33      40      46      49      63      46      40\n17 Other World …       5       2       3       4       2       7       3       4\n18 Unaffiliated      217     299     374     365     341     528     407     321\n# … with 2 more variables: `>150k` <dbl>, `Don't know/refused` <dbl>, and\n#   abbreviated variable names ¹​`$10-20k`, ²​`$20-30k`, ³​`$30-40k`, ⁴​`$40-50k`,\n#   ⁵​`$50-75k`, ⁶​`$75-100k`, ⁷​`$100-150k`\n```\n:::\n:::\n\n:::\n\n-   In this case the variables are religion, income bracket, and the number of respondents, which is the third variable, is presented inside the table.\n\nConverting this data to tidy format would give us\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nrelig_income %>%\n  pivot_longer(-religion, names_to = \"income\", values_to = \"respondents\") %>%\n  mutate(religion = factor(religion), income = factor(income))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 180 × 3\n   religion income             respondents\n   <fct>    <fct>                    <dbl>\n 1 Agnostic <$10k                       27\n 2 Agnostic $10-20k                     34\n 3 Agnostic $20-30k                     60\n 4 Agnostic $30-40k                     81\n 5 Agnostic $40-50k                     76\n 6 Agnostic $50-75k                    137\n 7 Agnostic $75-100k                   122\n 8 Agnostic $100-150k                  109\n 9 Agnostic >150k                       84\n10 Agnostic Don't know/refused          96\n# … with 170 more rows\n```\n:::\n:::\n\n\n# Reshaping data\n\n### `pivot_longer()`\n\nThe `tidyr` package includes functions to transfer a data frame between *long* and *wide*.\n\n-   **Wide format** data has different attributes or variables describing an observation _placed in separate columns_.\n-   **Long format** data tends to have different attributes encoded as _levels of a single variable_, followed by another column that contains _the values_ of the observation at those different levels.\n\n::: callout-tip\n### Example\n\nThe **key problem** with the tidyness of the original data is that the income variables are not in their own columns, but rather are embedded in the structure of the columns, making it hard to manipuate the income variables.\n\nTo **fix this**, you can use the `pivot_longer()` function to **gather values spread across several columns into a single column**, here with the column names gathered into an `income` column.\n\n**Note**: when gathering, exclude any columns that you do not want \"gathered\" (`religion` in this case) by including the column names with a the minus sign in the `pivot_longer()` function.\n\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Gather everything EXCEPT religion to tidy data\nrelig_income %>%\n  pivot_longer(-religion, names_to = \"income\", values_to = \"respondents\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 180 × 3\n   religion income             respondents\n   <chr>    <chr>                    <dbl>\n 1 Agnostic <$10k                       27\n 2 Agnostic $10-20k                     34\n 3 Agnostic $20-30k                     60\n 4 Agnostic $30-40k                     81\n 5 Agnostic $40-50k                     76\n 6 Agnostic $50-75k                    137\n 7 Agnostic $75-100k                   122\n 8 Agnostic $100-150k                  109\n 9 Agnostic >150k                       84\n10 Agnostic Don't know/refused          96\n# … with 170 more rows\n```\n:::\n:::\n\n:::\n\nEven if your data is in a tidy format, `pivot_longer()` is occasionally useful for pulling data together to take advantage of faceting, or plotting separate plots based on a grouping variable. \n\n\n### `pivot_wider()`\n\nThe `pivot_wider()` function is the opposite function. It is useful for creating summary tables for reports, but generally less commonly needed to tidy data. \n\n::: callout-tip\n### Example\n\nYou use the `summarize()` function in `dplyr` to summarize the total number of respondents per income category.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrelig_income %>%\n  pivot_longer(-religion, names_to = \"income\", values_to = \"respondents\") %>%\n  mutate(religion = factor(religion), income = factor(income)) %>% \n  group_by(income) %>% \n  summarize(total_respondents = sum(respondents)) %>%\n  pivot_wider(names_from = \"income\", \n              values_from = \"total_respondents\") %>%\n  knitr::kable()\n```\n\n::: {.cell-output-display}\n| <$10k| >150k| $10-20k| $100-150k| $20-30k| $30-40k| $40-50k| $50-75k| $75-100k| Don't know/refused|\n|-----:|-----:|-------:|---------:|-------:|-------:|-------:|-------:|--------:|------------------:|\n|  1930|  2608|    2781|      3197|    3357|    3302|    3085|    5185|     3990|               6121|\n:::\n:::\n\n:::\n\nNotice in this example how `pivot_wider()` has been used at the **very end of the code sequence** to convert the summarized data into a shape that **offers a better tabular presentation for a report**.\n\n\n::: callout-tip\n### Note\n\nIn the `pivot_wider()` call, you first specify the name of the column to use for the new column names (`income` in this example) and then specify the column to use for the cell values (`total_respondents` here).\n:::\n\n::: callout-tip\n### Example of `pivot_longer()`\n\nLet's try another dataset. This data contain an excerpt of the [Gapminder data](https://cran.r-project.org/web/packages/gapminder/README.html#gapminder) on life expectancy, GDP per capita, and population by country.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gapminder)\ngapminder\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# … with 1,694 more rows\n```\n:::\n:::\n\n\nIf we wanted to make `lifeExp`, `pop` and `gdpPercap` (all measurements that we observe) go from a wide table into a long table, what would we do?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# try it yourself\n```\n:::\n\n:::\n\n::: callout-tip\n### Example\n\nOne more! Try using `pivot_longer()` to convert the the following data that contains made-up revenues for three companies by quarter for years 2006 to 2009.\n\nAfterward, use `group_by()` and `summarize()` to calculate the average revenue for each company across all years and all quarters.\n\n**Bonus**: Calculate a mean revenue for each company AND each year (averaged across all 4 quarters).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  \"company\" = rep(1:3, each=4), \n  \"year\"  = rep(2006:2009, 3),\n  \"Q1\"    = sample(x = 0:100, size = 12),\n  \"Q2\"    = sample(x = 0:100, size = 12),\n  \"Q3\"    = sample(x = 0:100, size = 12),\n  \"Q4\"    = sample(x = 0:100, size = 12),\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 6\n   company  year    Q1    Q2    Q3    Q4\n     <int> <int> <int> <int> <int> <int>\n 1       1  2006    79    92    82    34\n 2       1  2007    96    74    89    41\n 3       1  2008    25    34    52    15\n 4       1  2009     1     7    64    62\n 5       2  2006    35    50    12    21\n 6       2  2007    98    14    48    53\n 7       2  2008    18    45    23    84\n 8       2  2009    40    94    79    93\n 9       3  2006    36    82    60    56\n10       3  2007    19    93     7    39\n11       3  2008    17     2    63    58\n12       3  2009    28    30    66    57\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# try it yourself \n```\n:::\n\n:::\n\n### `separate()` and `unite()` cells within columns of data\n\nStill in the`tidyr` package:\n\n-   `unite()`: combine contents of two or more columns into a single column\n-   `separate()`: separate contents of a column into two or more columns\n\nFirst, we combine the first three columns into one new column using `unite()`. This function is similar to `newvar <- paste(A,B,C, sep=\"_\")`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  unite(col=\"country_continent_year\", \n        country:year, \n        sep=\"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 4\n   country_continent_year lifeExp      pop gdpPercap\n   <chr>                    <dbl>    <int>     <dbl>\n 1 Afghanistan_Asia_1952     28.8  8425333      779.\n 2 Afghanistan_Asia_1957     30.3  9240934      821.\n 3 Afghanistan_Asia_1962     32.0 10267083      853.\n 4 Afghanistan_Asia_1967     34.0 11537966      836.\n 5 Afghanistan_Asia_1972     36.1 13079460      740.\n 6 Afghanistan_Asia_1977     38.4 14880372      786.\n 7 Afghanistan_Asia_1982     39.9 12881816      978.\n 8 Afghanistan_Asia_1987     40.8 13867957      852.\n 9 Afghanistan_Asia_1992     41.7 16317921      649.\n10 Afghanistan_Asia_1997     41.8 22227415      635.\n# … with 1,694 more rows\n```\n:::\n:::\n\n\nNext, we show how to separate the columns into three separate columns using `separate()` using the `col`, `into` and `sep` arguments. Note that this works by finding the delimiter, and relies on order of the information. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  unite(col=\"country_continent_year\", \n        country:year, \n        sep=\"_\") %>% \n  separate(col=\"country_continent_year\", \n           into=c(\"country\", \"continent\", \"year\"), \n           sep=\"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 6\n   country     continent year  lifeExp      pop gdpPercap\n   <chr>       <chr>     <chr>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia      1952     28.8  8425333      779.\n 2 Afghanistan Asia      1957     30.3  9240934      821.\n 3 Afghanistan Asia      1962     32.0 10267083      853.\n 4 Afghanistan Asia      1967     34.0 11537966      836.\n 5 Afghanistan Asia      1972     36.1 13079460      740.\n 6 Afghanistan Asia      1977     38.4 14880372      786.\n 7 Afghanistan Asia      1982     39.9 12881816      978.\n 8 Afghanistan Asia      1987     40.8 13867957      852.\n 9 Afghanistan Asia      1992     41.7 16317921      649.\n10 Afghanistan Asia      1997     41.8 22227415      635.\n# … with 1,694 more rows\n```\n:::\n:::\n\n\n# Joining data\n\n## Relational data\n\nData analyses rarely involve only a single table of data.\n\nTypically you have many tables of data, and you **must combine the datasets** to answer the questions that you are interested in.  Some examples include morphology and ecology data on the same species, or sequence data and metadata. \n\nCollectively, **multiple tables of data are called relational data** because it is the *relations*, not just the individual datasets, that are important.\n\nRelations are **always defined between a pair of tables**. All other relations are built up from this simple idea: the relations of three or more tables are always a property of the relations between each pair.\n\nSometimes both elements of a pair can be in the same table! This is needed if, for example, you have a table of people, and each person has a reference to their parents, or if you have nodes in a phylogeny and each is linked to an ancestral node.\n\nRelational data are combined with **merges or joins**.\n\n::: callout-tip\n### Three important families of joins\n\n-   [**Mutating joins**](https://r4ds.had.co.nz/relational-data.html#mutating-joins): A mutating join **combines variables from two tables**. It first matches observations by their keys, then copies across variables from one table to the other on the right side of the table (similar to `mutate()`). It mutates because it adds on. This is a typical __merge__ operation.\n    -   See @sec-mutjoins for Table of mutating joins.\n-   [**Filtering joins**](https://r4ds.had.co.nz/relational-data.html#filtering-joins): Filtering joins **match observations** in the same way as mutating joins, **but select the observations that match** (not the variables). In other words, this type of join filters observations from one data frame based on whether or not they match an observation in the other.\n    -   Two types: `semi_join(x, y)` and `anti_join(x, y)`.\n-   [**Set operations**](https://r4ds.had.co.nz/relational-data.html#set-operations): Treat **observations as if they were set elements**. Typically used less frequently, but occasionally useful when you want to break a single complex filter into simpler pieces. All these operations work with a complete row, comparing the values of every variable. These expect the x and y inputs to have the same variables, and treat the observations like sets:\n    -   Examples of set operations: `intersect(x, y)`, `union(x, y)`, and `setdiff(x, y)`.\n:::\n\n## Keys\n\nThe **variables used to connect each pair of tables** are called **keys**. A key is a variable (or set of variables) that __uniquely identifies an observation__. In simple cases, a single variable is sufficient to identify an observation.\n\n::: callout-tip\n### Note\n\nThere are two types of keys:\n\n-   A **primary key** uniquely identifies an observation in its own table.\n-   A **foreign key** uniquely identifies an observation in another table.\n:::\n\nLet's consider an example to help us understand the difference between a **primary key** and **foreign key**.\n\n## Example of keys\n\nImagine you are conduct a study and **collecting data on subjects and a health outcome**.\n\nOften, subjects will **have multiple observations** (a longitudinal study). Similarly, we may record other information, such as the type of housing.\n\n### The first table\n\nThis code creates a simple table with some made up data about some hypothetical subjects' outcomes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\noutcomes <- tibble(\n        id = rep(c(\"a\", \"b\", \"c\"), each = 3),\n        visit = rep(0:2, 3),\n        outcome = rnorm(3 * 3, 3)\n)\n\nprint(outcomes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 3\n  id    visit outcome\n  <chr> <int>   <dbl>\n1 a         0    3.24\n2 a         1    2.86\n3 a         2    3.41\n4 b         0    1.59\n5 b         1    4.28\n6 b         2    1.89\n7 c         0    2.36\n8 c         1    2.27\n9 c         2    2.55\n```\n:::\n:::\n\n\nNote that subjects are labeled by a unique identifer in the `id` column.\n\n### A second table\n\nHere is some code to create a second table containing  data about the hypothetical subjects' housing type.\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nsubjects <- tibble(\n        id = c(\"a\", \"b\", \"c\"),\n        house = c(\"detached\", \"rowhouse\", \"rowhouse\")\n)\n\nprint(subjects)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  id    house   \n  <chr> <chr>   \n1 a     detached\n2 b     rowhouse\n3 c     rowhouse\n```\n:::\n:::\n\n\n::: callout-note\n### Question\n\nWhat is the **primary key** and **foreign key**?\n\n-   The `outcomes$id` is a **primary key** because it uniquely identifies each subject in the `outcomes` table.\n-   The `subjects$id` is a **foreign key** because it appears in the `subjects` table where it matches each subject to a unique `id`.\n:::\n\n# Mutating joins {#sec-mutjoins}\n\nThe `dplyr` package provides a set of **functions for joining two data frames** into a single data frame based on a set of key columns.\n\nThere are several functions in the `*_join()` family.\n\n-   These functions all merge together two data frames\n-   They differ in how they handle observations that exist in one but not both data frames.\n\nHere, are the **four functions from this family** that you will likely use the most often:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n|Function       |What it includes in merged data frame                                                                     |\n|:--------------|:---------------------------------------------------------------------------------------------------------|\n|`left_join()`  |Includes all observations in the left data frame, whether or not there is a match in the right data frame |\n|`right_join()` |Includes all observations in the right data frame, whether or not there is a match in the left data frame |\n|`inner_join()` |Includes only observations that are in both data frames                                                   |\n|`full_join()`  |Includes all observations from both data frames                                                           |\n:::\n:::\n\n\n![](https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png)\n\n\\[[Source from R for Data Science](https://r4ds.had.co.nz/relational-data#relational-data)\\]\n\n\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Using prose, describe how the variables and observations are organised in a tidy dataset versus an non-tidy dataset.\n\n2.  What do the extra and fill arguments do in `separate()`? Experiment with the various options for the following two toy datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = c(\"a,b,c\", \"d,e,f,g\", \"h,i,j\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))\n\ntibble(x = c(\"a,b,c\", \"d,e\", \"f,g,i\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))\n```\n:::\n\n\n3.  Both `unite()` and `separate()` have a remove argument. What does it do? Why would you set it to FALSE?\n\n4.  Compare and contrast `separate()` and `extract()`. Why are there three variations of separation (by position, by separator, and with groups), but only one `unite()`?\n:::\n\n### Additional Resources\n\n::: callout-tip\n-   [Tidy Data](https://www.jstatsoft.org/article/view/v059i10) paper published in the Journal of Statistical Software\n-   https://r4ds.had.co.nz/tidy-data.html\n-   [tidyr cheat sheet from RStudio](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}