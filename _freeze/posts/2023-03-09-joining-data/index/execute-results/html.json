{
  "hash": "4975b30e415559aaa3036ddc954f42a6",
  "result": {
    "markdown": "---\ntitle: \"Joining data with dplyr\"\nauthor:\n  - name: Marguerite Butler\n    url: https://butlerlab.org\n    affiliation: School of Life Sciences, University of Hawaii\n    affiliation_url: https://manoa.hawaii.edu/lifesciences/\ndescription: \"Add\"\ndate: 2023-03-09\ncategories: [module 3, week 7, tidyr, tidyverse, dplyr, tibble, pipe]\n---\n\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://r4ds.had.co.nz/tidy-data>\n2.  [tidyr cheat sheet from RStudio](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)\n3.  <https://r4ds.had.co.nz/relational-data>\n4.  <https://rafalab.github.io/dsbook/joining-tables>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://www.stephaniehicks.com/jhustatcomputing2022/posts/2022-09-08-tidy-data-and-the-tidyverse/>\n-   <https://www.stephaniehicks.com/jhustatcomputing2022/posts/2022-09-08-joining-data-in-r/>\n-   <https://rdpeng.github.io/Biostat776/lecture-joining-data-in-r-basics>\n-   <https://r4ds.had.co.nz/relational-data>\n-   <https://rafalab.github.io/dsbook/joining-tables>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Be able to transform wide data into long data\n-   Be able to separate character columns into multiple columns\n-   Be able to unite/separate multiple character columns into one column\n-   Be able to define relational data and keys\n-   Be able to define the three types of join functions for relational data\n-   Be able to implement mutational join functions\n:::\n\n## New Packages\n\nYou will have to install if you donʻt already have them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"gapminder\")  # a dataset package\n```\n:::\n\n\n# Overview\n\nLast time we talked about tidy data. One common issue is that people sometimes use column names to store data. For example take a look at this built-in dataset that comes with `tidyr` on **religion and income survey data** with the number of respondents with income range in column name.\n\n\n# Joining data (a.k.a. Merging)\n\n## Relational data\n\nData analyses rarely involve only a single table of data.\n\nTypically you have many tables of data, and you **must combine the datasets** to answer the questions that you are interested in.  Some examples include morphology and ecology data on the same species, or sequence data and metadata. \n\nCollectively, **multiple tables of data are called relational data** because it is the *relations*, not just the individual datasets, that are important.\n\nRelations are **always defined between a pair of tables**. All other relations are built up from this simple idea: the relations of three or more tables are always a property of the relations between each pair.\n\nSometimes both elements of a pair can be in the same table! This is needed if, for example, you have a table of people, and each person has a reference to their parents, or if you have nodes in a phylogeny and each is linked to an ancestral node.\n\nRelational data are combined with **merges or joins**.\n\n::: callout-tip\n### Three important families of joins\n\n-   [**Mutating joins**](https://r4ds.had.co.nz/relational-data.html#mutating-joins): A mutating join **combines variables from two tables**. It first matches observations by their keys, then copies across variables from one table to the other on the right side of the table (similar to `mutate()`). It mutates because it adds on. This is a typical __merge__ operation.\n    -   See @sec-mutjoins for Table of mutating joins.\n-   [**Filtering joins**](https://r4ds.had.co.nz/relational-data.html#filtering-joins): Filtering joins **match observations** in the same way as mutating joins, **but select the observations that match** (not the variables). In other words, this type of join filters observations from one data frame based on whether or not they match an observation in the other.\n    -   Two types: `semi_join(x, y)` and `anti_join(x, y)`.\n-   [**Set operations**](https://r4ds.had.co.nz/relational-data.html#set-operations): Treat **observations as if they were set elements**. Typically used less frequently, but occasionally useful when you want to break a single complex filter into simpler pieces. All these operations work with a complete row, comparing the values of every variable. These expect the x and y inputs to have the same variables, and treat the observations like sets:\n    -   Examples of set operations: `intersect(x, y)`, `union(x, y)`, and `setdiff(x, y)`.\n:::\n\n## Keys\n\nThe **variables used to connect each pair of tables** are called **keys**. A key is a variable (or set of variables) that __uniquely identifies an observation__. In simple cases, a single variable is sufficient to identify an observation.\n\n::: callout-tip\n### Note\n\nThere are two types of keys:\n\n-   A **primary key** uniquely identifies an observation in its own table.\n-   A **foreign key** uniquely identifies an observation in another table.\n:::\n\nLet's consider an example to help us understand the difference between a **primary key** and **foreign key**.\n\n## Example of keys\n\nImagine you are conduct a study and **collecting data on subjects and a health outcome**.\n\nOften, subjects will **have multiple observations** (a longitudinal study). Similarly, we may record other information, such as the type of housing.\n\n### The first table\n\nThis code creates a simple table with some made up data about some hypothetical subjects' outcomes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\noutcomes <- tibble(\n        id = rep(c(\"a\", \"b\", \"c\"), each = 3),\n        visit = rep(0:2, 3),\n        outcome = rnorm(3 * 3, 3)\n)\n\nprint(outcomes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 3\n  id    visit outcome\n  <chr> <int>   <dbl>\n1 a         0    3.40\n2 a         1    1.41\n3 a         2    1.20\n4 b         0    5.54\n5 b         1    2.83\n6 b         2    3.42\n7 c         0    2.83\n8 c         1    3.52\n9 c         2    4.41\n```\n:::\n:::\n\n\nNote that subjects are labeled by a unique identifer in the `id` column.\n\n### A second table\n\nHere is some code to create a second table containing  data about the hypothetical subjects' housing type.\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nsubjects <- tibble(\n        id = c(\"a\", \"b\", \"c\"),\n        house = c(\"detached\", \"rowhouse\", \"rowhouse\")\n)\n\nprint(subjects)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  id    house   \n  <chr> <chr>   \n1 a     detached\n2 b     rowhouse\n3 c     rowhouse\n```\n:::\n:::\n\n\n::: callout-note\n### Question\n\nWhat is the **primary key** and **foreign key**?\n\n-   The `outcomes$id` is a **primary key** because it uniquely identifies each subject in the `outcomes` table.\n-   The `subjects$id` is a **foreign key** because it appears in the `subjects` table where it matches each subject to a unique `id`.\n:::\n\n# Mutating joins {#sec-mutjoins}\n\nThe `dplyr` package provides a set of **functions for joining two data frames** into a single data frame based on a set of key columns.\n\nThere are several functions in the `*_join()` family.\n\n-   These functions all merge together two data frames\n-   They differ in how they handle observations that exist in one but not both data frames.\n\nHere, are the **four functions from this family** that you will likely use the most often:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n|Function       |What it includes in merged data frame                                                                     |\n|:--------------|:---------------------------------------------------------------------------------------------------------|\n|`left_join()`  |Includes all observations in the left data frame, whether or not there is a match in the right data frame |\n|`right_join()` |Includes all observations in the right data frame, whether or not there is a match in the left data frame |\n|`inner_join()` |Includes only observations that are in both data frames                                                   |\n|`full_join()`  |Includes all observations from both data frames                                                           |\n:::\n:::\n\n\n![](https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png)\n\n\\[[Source from R for Data Science](https://r4ds.had.co.nz/relational-data#relational-data)\\]\n\n\n\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Using prose, describe how the variables and observations are organised in a tidy dataset versus an non-tidy dataset.\n\n2.  What do the extra and fill arguments do in `separate()`? Experiment with the various options for the following two toy datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = c(\"a,b,c\", \"d,e,f,g\", \"h,i,j\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))\n\ntibble(x = c(\"a,b,c\", \"d,e\", \"f,g,i\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))\n```\n:::\n\n\n3.  Both `unite()` and `separate()` have a remove argument. What does it do? Why would you set it to FALSE?\n\n4.  Compare and contrast `separate()` and `extract()`. Why are there three variations of separation (by position, by separator, and with groups), but only one `unite()`?\n:::\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}