[
  {
    "objectID": "posts/2023-02-14-tidying-exploring-data/index.html",
    "href": "posts/2023-02-14-tidying-exploring-data/index.html",
    "title": "Tidying and Exploring Data",
    "section": "",
    "text": "✏️"
  },
  {
    "objectID": "posts/2023-02-14-tidying-exploring-data/index.html#acknowledgements",
    "href": "posts/2023-02-14-tidying-exploring-data/index.html#acknowledgements",
    "title": "Tidying and Exploring Data",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nMaterial for this lecture was borrowed and adopted from"
  },
  {
    "objectID": "posts/2023-02-14-tidying-exploring-data/index.html#vectors",
    "href": "posts/2023-02-14-tidying-exploring-data/index.html#vectors",
    "title": "Tidying and Exploring Data",
    "section": "Vectors",
    "text": "Vectors\nThe index of a vector is it’s number in the array. Each and every element in any data object has at least one index (if vector, it is one dimensional so it is its position along the vector, if a matrix or data frame, which are two-dimensional, it’s the row and column number, etc.)\nLet’s create a vector:\n\nxx <- c(1, 5, 2, 3, 5)\nxx\n\n[1] 1 5 2 3 5\n\n\nAccess specific values of xx by number:\n\nxx[1]\n\n[1] 1\n\nxx[3]\n\n[1] 2\n\n\nYou can use a function to generate an index. Get the last element (without knowing how many there are) by:\n\nxx[length(xx)]\n\n[1] 5\n\n\nRetrieve multiple elements of xx by using a vector as an argument:\n\nxx[c(1, 3, 4)]\n\n[1] 1 2 3\n\nxx[1:3]\n\n[1] 1 5 2\n\nxx[c(1, length(xx))]  # first and last\n\n[1] 1 5\n\n\nExclude elements by using a negative index:\n\nxx\n\n[1] 1 5 2 3 5\n\nxx[-1]  # exclude first\n\n[1] 5 2 3 5\n\nxx[-2] # exclude second\n\n[1] 1 2 3 5\n\nxx[-(1:3)] # exclude first through third\n\n[1] 3 5\n\nxx[-c(2, 4)] # exclude second and fourth, etc. \n\n[1] 1 2 5\n\n\nUse a logical vector:\n\nxx[ c( T, F, T, F, T) ]  # T is the same as TRUE\n\n[1] 1 2 5\n\n\n\nxx > 2\n\n[1] FALSE  TRUE FALSE  TRUE  TRUE\n\nxx[ xx > 2 ]\n\n[1] 5 3 5\n\nxx > 2 & xx < 5\n\n[1] FALSE FALSE FALSE  TRUE FALSE\n\nxx[ xx>2 & xx<5]\n\n[1] 3\n\n\nSubsetting (picking particular observations out of an R object) is something that you will have to do all the time. It’s worth the time to understand it clearly.\n\nsubset_xx <-  xx[ xx > 2 ]\nsubset_xx2 <- subset(xx, xx>2)  # using subset function\nsubset_xx == subset_xx2   # check if the same\n\n[1] TRUE TRUE TRUE\n\n\nThe subset function is just another way of subsetting by index, just in function form with arguments. It can be more clear to use for dataframes, but it is really a matter of personal preference as you develop your style. Whichever way you go, it is important to be aware of the different ways to achieve the same goals."
  },
  {
    "objectID": "posts/2023-02-14-tidying-exploring-data/index.html#matrices-and-dataframes",
    "href": "posts/2023-02-14-tidying-exploring-data/index.html#matrices-and-dataframes",
    "title": "Tidying and Exploring Data",
    "section": "Matrices and Dataframes",
    "text": "Matrices and Dataframes\nMatrices and dataframes are both rectangular having two dimensions, and are handled very similarly for indexing and subsetting.\nLet’s work with a dataframe that is provided with the geiger package called geospiza. It is a list with a tree and a dataframe. The dataframe contains five morphological measurements for 13 species. First, let’s clear the workspace (or clear and start a new R session):\n\ninstall.packages(\"geiger\")  # if you need to install geiger\n\nGet the built-in dataset this way:\n\nrm(list=ls())\nrequire(geiger)\n\nLoading required package: geiger\n\n\nLoading required package: ape\n\ndata(geospiza)   # load the dataset into the workspace\nls()               # list the objects in the workspace\n\n[1] \"geospiza\"\n\n\nLet’s find out some basic information about this object:\n\nclass(geospiza)\n\n[1] \"list\"\n\nattributes(geospiza)\n\n$names\n[1] \"geospiza.tree\" \"geospiza.data\" \"phy\"           \"dat\"          \n\nstr(geospiza)\n\nList of 4\n $ geospiza.tree:List of 4\n  ..$ edge       : num [1:26, 1:2] 15 16 17 18 19 20 21 22 23 24 ...\n  ..$ edge.length: num [1:26] 0.2974 0.0492 0.0686 0.134 0.1035 ...\n  ..$ Nnode      : int 13\n  ..$ tip.label  : chr [1:14] \"fuliginosa\" \"fortis\" \"magnirostris\" \"conirostris\" ...\n  ..- attr(*, \"class\")= chr \"phylo\"\n $ geospiza.data: num [1:13, 1:5] 4.4 4.35 4.22 4.26 4.24 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:13] \"magnirostris\" \"conirostris\" \"difficilis\" \"scandens\" ...\n  .. ..$ : chr [1:5] \"wingL\" \"tarsusL\" \"culmenL\" \"beakD\" ...\n $ phy          :List of 4\n  ..$ edge       : num [1:26, 1:2] 15 16 17 18 19 20 21 22 23 24 ...\n  ..$ edge.length: num [1:26] 0.2974 0.0492 0.0686 0.134 0.1035 ...\n  ..$ Nnode      : int 13\n  ..$ tip.label  : chr [1:14] \"fuliginosa\" \"fortis\" \"magnirostris\" \"conirostris\" ...\n  ..- attr(*, \"class\")= chr \"phylo\"\n $ dat          : num [1:13, 1:5] 4.4 4.35 4.22 4.26 4.24 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:13] \"magnirostris\" \"conirostris\" \"difficilis\" \"scandens\" ...\n  .. ..$ : chr [1:5] \"wingL\" \"tarsusL\" \"culmenL\" \"beakD\" ...\n\n\nIt is a list with four elements. Here we want the data\n\ngeo <- as.data.frame(geospiza$geospiza.data)\ndim(geo)\n\n[1] 13  5\n\n\nIt is a dataframe with 13 rows and 5 columns. If we want to know all the attributes of geo:\n\nattributes(geo)\n\n$names\n[1] \"wingL\"   \"tarsusL\" \"culmenL\" \"beakD\"   \"gonysW\" \n\n$class\n[1] \"data.frame\"\n\n$row.names\n [1] \"magnirostris\" \"conirostris\"  \"difficilis\"   \"scandens\"     \"fortis\"      \n [6] \"fuliginosa\"   \"pallida\"      \"fusca\"        \"parvulus\"     \"pauper\"      \n[11] \"Pinaroloxias\" \"Platyspiza\"   \"psittacula\"  \n\n\nWe see that it has a “names” attribute, which refers to column names in a dataframe. Typically, the columns of a dataframe are the variables in the dataset. It also has “rownames” which contains the species names (so it does not have a separate column for species names).\nDataframes have two dimensions which we can use to index with: dataframe[row, column].\n\ngeo     # the entire object, same as geo[] or geo[,]\ngeo[c(1, 3), ]   # select the first and third rows, all columns\ngeo[, 3:5]   # all rows, third through fifth columns\ngeo[1, 5]  # first row, fifth column (a single number)\ngeo[1:2, c(3, 1)]  # first and second row, third and first column (2x2 matrix)\ngeo[-c(1:3, 10:13), ]  # everything but the first three and last three rows\ngeo[ 1:3, 5:1]  # first three species, but variables in reverse order\n\nTo prove to ourselves that we can access matrices in the same way, let’s coerce geo to be a matrix:\n\ngeom <- as.matrix( geo ) \nclass(geom)\n\n[1] \"matrix\" \"array\" \n\nclass(geo)\n\n[1] \"data.frame\"\n\ngeo[1,5]  # try a few more from the choices above to test\n\n[1] 2.675983\n\n\nSince geo and geom have row and column names, we can access by name (show that this works for geom too):\n\ngeo[\"pauper\", \"wingL\"]  # row pauper, column wingL\n\n[1] 4.2325\n\ngeo[\"pauper\", ]  # row pauper, all columns \n\n        wingL tarsusL culmenL  beakD gonysW\npauper 4.2325  3.0359   2.187 2.0734 1.9621\n\n\nWe can also use the names (or rownames) attribute if we are lazy. Suppose we wanted all the species which began with “pa”. we could find which position they hold in the dataframe by looking at the rownames, saving them to a vector, and then indexing by them:\n\nsp <- rownames(geo)\nsp                            # a vector of the species names\n\n [1] \"magnirostris\" \"conirostris\"  \"difficilis\"   \"scandens\"     \"fortis\"      \n [6] \"fuliginosa\"   \"pallida\"      \"fusca\"        \"parvulus\"     \"pauper\"      \n[11] \"Pinaroloxias\" \"Platyspiza\"   \"psittacula\"  \n\nsp[c(7,8,10)]     # the ones we want are #7,8, and 10\n\n[1] \"pallida\" \"fusca\"   \"pauper\" \n\ngeo[ sp[c(7,8,10)], ]  # rows 7,8 and 10, same as geo[c(7, 8, 10)]\n\n           wingL  tarsusL  culmenL    beakD   gonysW\npallida 4.265425 3.089450 2.430250 2.016350 1.949125\nfusca   3.975393 2.936536 2.051843 1.191264 1.401186\npauper  4.232500 3.035900 2.187000 2.073400 1.962100\n\n\nOne difference between dataframes and matrices is that Indexing a data frame by a single vector (meaning, no comma separating) selects an entire column. This can be done by name or by number:\n\ngeo[3]   # third column\ngeo[\"culmenL\"]  # same\ngeo[c(3,5)]  # third and fifth column\ngeo[c(\"culmenL\", \"gonysW\")]  # same\n\nProve to yourself that selecting by a single index has a different behavior for matrices (and sometimes produces an error.\n\n\n\n\n\n\nWhy?\n\n\n\n\nBecause internally, a dataframe is actually a list of vectors. Thus a single name or number refers to the column, rather than a coordinate in a cartesian-coordinate-like system.\nHowever, a matrix is actually a vector with breaks in it. So a single number refers to a position along the single vector.\nA single name could work, but only if the individual elements of the matrix have names (like naming the individual elements of a vector).\n\n\n\nAnother difference is that dataframes (and lists below) can be accessed by the $ operator. It means indicates a column within a dataframe, so dataframe$column. This is another way to select by column:\n\ngeo$culmenL\n\n [1] 2.724667 2.654400 2.277183 2.621789 2.407025 2.094971 2.430250 2.051843\n [9] 1.974420 2.187000 2.311100 2.331471 2.259640\n\n\nAn equivalent way to index is by using the subset function. Some people prefer it because you have explicit parameters for what to select and which variables to include. See help page ?subset."
  },
  {
    "objectID": "posts/2023-02-14-tidying-exploring-data/index.html#lists",
    "href": "posts/2023-02-14-tidying-exploring-data/index.html#lists",
    "title": "Tidying and Exploring Data",
    "section": "Lists",
    "text": "Lists\nA list is a vector, except that whereas an ordinary vector has the same type of data (numeric, character, factor) in each slot, a list can have different types in different slots. They are sort of like expandable containers, flexibly accommodating any group of objects that the user wants to keep together.\nThey are accessed by numeric index or by name (if they are named), but they are accessed by double square brackets. Also, you can’t access multiple elements of lists by using vectors of indices:\n\nmylist <- list( vec = 2*1:10, mat = matrix(1:10, nrow=2), cvec = c(\"frogs\", \"birds\"))\nmylist\n\n$vec\n [1]  2  4  6  8 10 12 14 16 18 20\n\n$mat\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n\n$cvec\n[1] \"frogs\" \"birds\"\n\nmylist[[2]]\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n\nmylist[[\"vec\"]]\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n# mylist[[1:3]]  # gives an error if you uncomment it\nmylist$cvec\n\n[1] \"frogs\" \"birds\""
  },
  {
    "objectID": "posts/2023-02-14-tidying-exploring-data/index.html#missing-values",
    "href": "posts/2023-02-14-tidying-exploring-data/index.html#missing-values",
    "title": "Tidying and Exploring Data",
    "section": "Missing Values",
    "text": "Missing Values\nMissing values compared to anything else will return a missing value (so NA == NA returns NA, which is usually not what you want). You must test it with is.na function. You can also test multiple conditions with and (&) and or (|)\n\n!is.na(geo$gonysW) \n\n [1]  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE\n[13]  TRUE\n\ngeo[!is.na(geo$gonysW) & geo$wingL > 4, ]  # element by element \"and\"\n\n                wingL  tarsusL  culmenL    beakD   gonysW\nconirostris  4.349867 2.984200 2.654400 2.513800 2.360167\nfortis       4.244008 2.894717 2.407025 2.362658 2.221867\nmagnirostris 4.404200 3.038950 2.724667 2.823767 2.675983\npsittacula   4.235020 3.049120 2.259640 2.230040 2.073940\nplatyspiza   4.419686 3.270543 2.331471 2.347471 2.282443\nscandens     4.261222 2.929033 2.621789 2.144700 2.036944\n\ngeo[!is.na(geo$gonysW) | geo$wingL > 4, ]   # element by element \"or\"\n\n                wingL  tarsusL  culmenL    beakD   gonysW\nconirostris  4.349867 2.984200 2.654400 2.513800 2.360167\ndifficilis   4.224067 2.898917 2.277183 2.011100       NA\nfuliginosa   4.132957 2.806514 2.094971       NA       NA\nfortis       4.244008 2.894717 2.407025 2.362658 2.221867\nmagnirostris 4.404200 3.038950 2.724667 2.823767 2.675983\nparvulus     4.131600 2.973060       NA       NA       NA\npinaroloxias 4.188600 2.980200 2.311100       NA       NA\npauper       4.232500 3.035900 2.187000 2.073400       NA\npsittacula   4.235020 3.049120 2.259640 2.230040 2.073940\npallida      4.265425 3.089450 2.430250 2.016350       NA\nplatyspiza   4.419686 3.270543 2.331471 2.347471 2.282443\nscandens     4.261222 2.929033 2.621789 2.144700 2.036944\n\n!is.na(geo$gonysW) && geo$wingL > 4   # vectorwise \"and\"\n\nWarning in !is.na(geo$gonysW) && geo$wingL > 4: 'length(x) = 13 > 1' in coercion\nto 'logical(1)'\n\nWarning in !is.na(geo$gonysW) && geo$wingL > 4: 'length(x) = 13 > 1' in coercion\nto 'logical(1)'\n\n\n[1] TRUE\n\n\nMatching works on strings also:\n\ngeo[rownames(geo) == \"pauper\",]   # same as   geo[\"pauper\", ]\ngeo[rownames(geo) < \"pauper\",]\n\nThere are even better functions for strings, though. In the expression A %in% B, the %in% operator compares two vectors of strings, and tells us which elements of A are present in B.\n\nnewsp <- c(\"clarkii\", \"pauper\", \"garmani\")\nnewsp[newsp  %in% rownames(geo)]     # which new species are in geo?\n\nWe can define the “without” operator:\n\n\"%w/o%\" <- function(x, y) x[!x %in% y]\nnewsp  %w/o% rownames(geo)   # which new species are not in geo?"
  },
  {
    "objectID": "posts/2023-02-14-tidying-exploring-data/index.html#plot",
    "href": "posts/2023-02-14-tidying-exploring-data/index.html#plot",
    "title": "Tidying and Exploring Data",
    "section": "Plot()",
    "text": "Plot()\nFor a generic x-y plot use plot(). It will also start a graphical device.\nHere we are using the with() function to specify which dataframe to look into for our named variables. We could instead do penguins$body_mass_g, etc.\n\nwith(penguins, plot( body_mass_g, bill_length_mm))\n\n\n\n\nTo add points to an existing plot, use points()\n\nwith(penguins[penguins$species==\"Adelie\",], points( body_mass_g, bill_length_mm, col=\"red\"))\n\nOne could fit linear models, for example, and use lines() to overlay the line on the plot."
  },
  {
    "objectID": "posts/2023-02-14-tidying-exploring-data/index.html#distribution-using-hist-and-density",
    "href": "posts/2023-02-14-tidying-exploring-data/index.html#distribution-using-hist-and-density",
    "title": "Tidying and Exploring Data",
    "section": "Distribution using hist() and density()",
    "text": "Distribution using hist() and density()\nTo see a histogram, use hist(). You can change the breaks and many other features by checking out the help page ?hist\n\nwith(penguins, hist( body_mass_g ))\n\n\n\n\nTo see a density plot use density() to create the density, then plot it.\n\ndens <- with(penguins, density( body_mass_g, na.rm=T ))\nplot(dens)"
  }
]